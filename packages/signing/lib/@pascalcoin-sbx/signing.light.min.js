!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t(require("@pascalcoin-sbx/common"),require("@pascalcoin-sbx/crypto")):"function"==typeof define&&define.amd?define("@pascalcoin-sbx/signing",["@pascalcoin-sbx/common","@pascalcoin-sbx/crypto"],t):"object"==typeof exports?exports["@pascalcoin-sbx/signing"]=t(require("@pascalcoin-sbx/common"),require("@pascalcoin-sbx/crypto")):e["@pascalcoin-sbx/signing"]=t(e["@pascalcoin-sbx/common"],e["@pascalcoin-sbx/crypto"])}("undefined"!=typeof self?self:this,function(e,t){return function(e){var t={};function n(o){if(t[o])return t[o].exports;var i=t[o]={i:o,l:!1,exports:{}};return e[o].call(i.exports,i,i.exports,n),i.l=!0,i.exports}return n.m=e,n.c=t,n.d=function(e,t,o){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:o})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var o=Object.create(null);if(n.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var i in e)n.d(o,i,function(t){return e[t]}.bind(null,i));return o},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=24)}([function(t,n){t.exports=e},function(e,t,n){const o=n(0).BC,i=n(0).Types.Currency,r=n(0).PascalCoinInfo,s=Symbol("payload"),a=Symbol("s"),c=Symbol("r"),p=Symbol("fee"),u=Symbol("nOperation");e.exports=class{constructor(){this[s]=o.fromString(""),this[a]=null,this[c]=null,this[p]=new i(0)}withPayload(e){return this[s]=e,this}withFee(e){return this[p]=new i(e),this}withMinFee(e=null){return this[p]=r.MIN_FEE(e),this}withNOperation(e){return this[u]=e,this}withSign(e,t){this[c]=e,this[a]=t}get payload(){return this[s]}get r(){return this[c]}get s(){return this[a]}get fee(){return this[p]}get nOperation(){return this[u]}get isSigned(){return null!==this[a]&&null!==this[c]}usesDigestToSign(){return!1}}},function(e,t,n){const o=n(0).Coding.Pascal.Keys.PublicKey,i=n(0).Coding.Core.BytesWithLength,r=n(0).Types.Keys.PublicKey,s=new o;e.exports=class extends i{constructor(e=null){super(e||"pubkey",2)}decodeFromBytes(e,t={},n=null){const o=super.decodeFromBytes(e),i=s.decodeFromBytes(o);return new r(i.x,i.y,i.curve)}encodeToBytes(e){return super.encodeToBytes(s.encodeToBytes(e))}}},function(e,t,n){const o=n(0).Endian,i=n(0).Coding,r=i.CompositeType,s=n(22);class a extends r{constructor(){super("change_key_op_raw"),this.description("The coder for the raw representation of a ChangeKey operation"),this.addSubType(new i.Core.Int16("protocol").description("The protocol version (3).").withFixedValue(3)),this.addSubType(new i.Core.Int16("sendersCount",!0,o.LITTLE_ENDIAN).description("The number of senders")),this.addSubType(new i.Repeating("senders",new a).description("Senders of the multi-operation")),this.addSubType(new i.Core.Int16("receiversCount",!0,o.LITTLE_ENDIAN).description("The number of receivers")),this.addSubType(new i.Repeating("receivers",new a).description("Receivers of the multi-operation")),this.addSubType(new i.Core.Int16("changersCount",!0,o.LITTLE_ENDIAN).description("The number of changers")),this.addSubType(new i.Repeating("changers",new a).description("Changers of the multi-operation"))}get typeInfo(){let e=super.typeInfo;return e.name="Change Key Operation (RAW)",e.hierarchy.push(e.name),e}decodeFromBytes(e,t={},n=null){const o=super.decodeFromBytes(e),i=new s(o.signer,o.newPublicKey);return i.withFee(o.fee),i.withPayload(o.payload),i.withNOperation(o.nOperation),i.withSign(o.r,o.s),i}}e.exports=a},function(e,t,n){const o=n(0).Sha,i=n(26).Keys,r=n(5);e.exports=class{sign(e,t){const n=new(r.digestCoderFor(t))(t.opType).encodeToBytes(t);let s;return s=!0===t.usesDigestToSign()?function(e,t){return i.sign(e,t)}(e,n):function(e,t){const n=o.sha256(t);return i.sign(e,n)}(e,n)}signMultiOperation(e){}}},function(e,t,n){let o={ChangeKey:{Operation:n(6),RawCoder:n(7),DigestCoder:n(27)},ChangeKeySigned:{Operation:n(8),RawCoder:n(9),DigestCoder:n(28)},ChangeAccountInfo:{Operation:n(10),RawCoder:n(11),DigestCoder:n(29)},Data:{Operation:n(12),RawCoder:n(13),DigestCoder:n(30)},Transaction:{Operation:n(14),RawCoder:n(15),DigestCoder:n(31)},ListAccountForSale:{Operation:n(16),RawCoder:n(17),DigestCoder:n(32)},DeListAccountForSale:{Operation:n(18),RawCoder:n(19),DigestCoder:n(33)},BuyAccount:{Operation:n(20),RawCoder:n(21),DigestCoder:n(34)},MultiOperation:{Operation:n(22),RawCoder:n(3),DigestCoder:n(3)},digestCoderFor:e=>o[e.constructor.name].DigestCoder};e.exports=o},function(e,t,n){const o=n(1),i=n(0).Types.AccountNumber,r=Symbol("signer"),s=Symbol("new_public_key");e.exports=class extends o{get opType(){return 2}constructor(e,t){super(),this[r]=new i(e),this[s]=t}get signer(){return this[r]}get newPublicKey(){return this[s]}}},function(e,t,n){const o=n(0).Coding,i=o.CompositeType,r=n(0).Types.Keys.PublicKey,s=n(6),a=n(2);e.exports=class extends i{constructor(){super("change_key_op_raw"),this.description("The coder for the raw representation of a ChangeKey operation"),this.addSubType(new o.Pascal.AccountNumber("signer").description("The signer of the operation.")),this.addSubType((new o.Pascal.NOperation).description("The next n_operation value of the buyer.")),this.addSubType(new o.Pascal.Currency("fee").description("The fee paid for the operation.")),this.addSubType(new o.Core.BytesWithLength("payload",2).description("The payload of the operation.")),this.addSubType(new o.Pascal.Keys.PublicKey("v2_public_key").description("Empty pubkey (6 zero bytes) - previously active in <= v2.").withFixedValue(r.empty())),this.addSubType(new a("newPublicKey").description("The new public key of the account.")),this.addSubType(new o.Core.BytesWithLength("r",2).description("R value of the sign operation.")),this.addSubType(new o.Core.BytesWithLength("s",2).description("S value of the sign operation."))}get typeInfo(){let e=super.typeInfo;return e.name="Change Key Operation (RAW)",e.hierarchy.push(e.name),e}decodeFromBytes(e,t={},n=null){const o=super.decodeFromBytes(e),i=new s(o.signer,o.newPublicKey);return i.withFee(o.fee),i.withPayload(o.payload),i.withNOperation(o.nOperation),i.withSign(o.r,o.s),i}}},function(e,t,n){const o=n(1),i=n(0).Types.AccountNumber,r=Symbol("signer"),s=Symbol("target"),a=Symbol("new_public_key");e.exports=class extends o{get opType(){return 7}constructor(e,t,n){super(),this[r]=new i(e),this[s]=new i(t),this[a]=n}get signer(){return this[r]}get target(){return this[s]}get newPublicKey(){return this[a]}}},function(e,t,n){const o=n(0).Coding,i=o.CompositeType,r=n(0).Types.Keys.PublicKey,s=n(8),a=n(2);e.exports=class extends i{constructor(){super("change_key_signed_op_raw"),this.description("The coder for the raw representation of a ChangeKeySigned operation"),this.addSubType(new o.Pascal.AccountNumber("signer").description("The signer of the operation.")),this.addSubType(new o.Pascal.AccountNumber("target").description("The target account to be changed.")),this.addSubType((new o.Pascal.NOperation).description("The next n_operation value of the buyer.")),this.addSubType(new o.Pascal.Currency("fee").description("The fee paid for the operation.")),this.addSubType(new o.Core.BytesWithLength("payload",2).description("The payload of the operation.")),this.addSubType(new o.Pascal.Keys.PublicKey("v2_public_key").description("Empty pubkey (6 zero bytes) - previously active in <= v2.").withFixedValue(r.empty())),this.addSubType(new a("newPublicKey").description("The new public key of the account.")),this.addSubType(new o.Core.BytesWithLength("r",2).description("R value of the sign operation.")),this.addSubType(new o.Core.BytesWithLength("s",2).description("S value of the sign operation."))}get typeInfo(){let e=super.typeInfo;return e.name="Change Key Signed Operation (RAW)",e.hierarchy.push(e.name),e}decodeFromBytes(e,t={},n=null){const o=super.decodeFromBytes(e),i=new s(o.signer,o.target,o.newPublicKey);return i.withFee(o.fee),i.withPayload(o.payload),i.withNOperation(o.nOperation),i.withSign(o.r,o.s),i}}},function(e,t,n){const o=n(1),i=n(0).BC,r=n(0).Types.Keys.PublicKey,s=n(0).Types.AccountNumber,a=n(0).Types.AccountName,c=Symbol("account_signer"),p=Symbol("account_target"),u=Symbol("new_public_key"),d=Symbol("new_name"),h=Symbol("new_type"),y=Symbol("with_new_pubkey"),l=Symbol("with_new_name"),b=Symbol("with_new_type");e.exports=class extends o{get opType(){return 8}constructor(e,t){super(),this[c]=new s(e),this[p]=new s(t),this[u]=r.empty(),this[d]=i.fromString(""),this[h]=0,this[y]=!1,this[l]=!1,this[b]=!1}get signer(){return this[c]}get target(){return this[p]}get newPublicKey(){return this[u]}get newName(){return this[d]}get newType(){return this[h]}get changeType(){let e=0;return!0===this[y]&&(e|=1),!0===this[l]&&(e|=2),!0===this[b]&&(e|=4),e}withNewPublicKey(e){return this[u]=e,this[y]=!0,this}withNewName(e){return this[d]=new a(e),this[l]=!0,this}withNewType(e){return this[h]=e,this[b]=!0,this}}},function(e,t,n){const o=n(0).Coding,i=o.CompositeType,r=n(0).Types.Keys.PublicKey,s=n(10);e.exports=class extends i{constructor(){super("change_account_info_op_raw"),this.description("The coder for the raw representation of a ChangeAccountInfo operation"),this.addSubType(new o.Pascal.AccountNumber("signer").description("The signer of the operation.")),this.addSubType(new o.Pascal.AccountNumber("target").description("The target account to change info of.")),this.addSubType((new o.Pascal.NOperation).description("The next n_operation value of the buyer.")),this.addSubType(new o.Pascal.Currency("fee").description("The fee paid for the operation.")),this.addSubType(new o.Core.BytesWithLength("payload",2).description("The payload of the operation.")),this.addSubType(new o.Pascal.Keys.PublicKey("v2_public_key").description("Empty pubkey (6 zero bytes) - previously active in <= v2.").withFixedValue(r.empty())),this.addSubType(new o.Core.Int8("changeType").description("The change type.")),this.addSubType(new o.Pascal.Keys.PublicKey("newPublicKey").description("The new public key of the account.")),this.addSubType(new o.Pascal.AccountName("newName").description("The new name of the account.")),this.addSubType(new o.Core.Int16("newType").description("The new type of the account.")),this.addSubType(new o.Core.BytesWithLength("r",2).description("R value of the sign operation.")),this.addSubType(new o.Core.BytesWithLength("s",2).description("S value of the sign operation."))}get typeInfo(){let e=super.typeInfo;return e.name="Change Account Info Operation (RAW)",e.hierarchy.push(e.name),e}decodeFromBytes(e,t={},n=null){const o=super.decodeFromBytes(e),i=new s(o.signer,o.target);return i.withNewType(o.type),i.withNewName(o.name),i.withNewPublicKey(o.newPublicKey),i.withFee(o.fee),i.withPayload(o.payload),i.withNOperation(o.nOperation),i.withSign(o.r,o.s),i}}},function(e,t,n){const o=n(1),i=n(0).Types.AccountNumber,r=n(0).Types.Currency,s=Symbol("account_signer"),a=Symbol("account_sender"),c=Symbol("account_target"),p=Symbol("data_type"),u=Symbol("data_sequence"),d=Symbol("amount");e.exports=class extends o{get opType(){return 10}constructor(e,t,n){super(),this[s]=new i(e),this[a]=new i(t),this[c]=new i(n),this[p]=0,this[u]=0,this[d]=new r(0)}withDataType(e){return this[p]=parseInt(e,10),this}withDataSequence(e){return this[u]=parseInt(e,10),this}withAmount(e){return this[d]=new r(e),this}get signer(){return this[s]}get sender(){return this[a]}get target(){return this[c]}get dataType(){return this[p]}get dataSequence(){return this[u]}get amount(){return this[d]}usesDigestToSign(){return!0}}},function(e,t,n){const o=n(0).Coding,i=n(0).Endian,r=o.CompositeType,s=n(12);e.exports=class extends r{constructor(){super("data_operation_raw"),this.description("The coder for the raw representation of a Data operation"),this.addSubType(new o.Pascal.AccountNumber("signer").description("The account that executes the operation.")),this.addSubType(new o.Pascal.AccountNumber("sender").description("The account that sends the operation.")),this.addSubType(new o.Pascal.AccountNumber("target").description("The account that will receive the operation.")),this.addSubType((new o.Pascal.NOperation).description("The next n_operation of the signer.")),this.addSubType(new o.Core.Int16("dataType",!0,i.LITTLE_ENDIAN).description("The data type of the operation.")),this.addSubType(new o.Core.Int16("dataSequence",!0,i.LITTLE_ENDIAN).description("The data sequence of the operation.")),this.addSubType(new o.Pascal.Currency("amount").description("The amount associated the operation.")),this.addSubType(new o.Pascal.Currency("fee").description("The fee associated the operation.")),this.addSubType(new o.Core.BytesWithLength("payload",2).description("The payload of the operation.")),this.addSubType(new o.Core.BytesWithLength("r",2).description("R value of the signed operation.")),this.addSubType(new o.Core.BytesWithLength("s",2).description("R value of the signed operation."))}get typeInfo(){let e=super.typeInfo;return e.name="Data Operation (RAW)",e.hierarchy.push(e.name),e}decodeFromBytes(e,t={},n=null){const o=super.decodeFromBytes(e),i=new s(o.signer,o.sender,o.target);return i.withDataType(o.dataType),i.withDataSequence(o.dataSequence),i.withAmount(o.amount),i.withFee(o.fee),i.withPayload(o.payload),i.withNOperation(o.nOperation),i.withSign(o.r,o.s),i}}},function(e,t,n){const o=n(1),i=n(0).Types.Currency,r=n(0).Types.AccountNumber,s=Symbol("sender"),a=Symbol("target"),c=Symbol("amount");e.exports=class extends o{get opType(){return 1}constructor(e,t,n){super(),this[s]=new r(e),this[a]=new r(t),this[c]=new i(n)}get sender(){return this[s]}get target(){return this[a]}get amount(){return this[c]}}},function(e,t,n){const o=n(0).Coding,i=n(0).Types.Keys.PublicKey,r=o.CompositeType,s=n(14);e.exports=class extends r{constructor(){super("data_operation_raw"),this.description("The coder for the raw representation of a Transaction operation"),this.addSubType(new o.Pascal.AccountNumber("sender").description("The sender account.")),this.addSubType(new o.Pascal.NOperation("nOperation").description("The next n_operation value of the sender.")),this.addSubType(new o.Pascal.AccountNumber("target").description("The receiving account.")),this.addSubType(new o.Pascal.Currency("amount").description("The amount that is sent from sender to receiver.")),this.addSubType(new o.Pascal.Currency("fee").description("The fee included in the operation.")),this.addSubType(new o.Core.BytesWithLength("payload",2).description("The payload of the operation.")),this.addSubType(new o.Pascal.Keys.PublicKey("v2_pubkey").description("Empty pubkey (6 zero bytes) - previously active in <= v2.").withFixedValue(i.empty())),this.addSubType(new o.Core.BytesWithLength("r",2).description("R value of the signed operation.")),this.addSubType(new o.Core.BytesWithLength("s",2).description("S value of the signed operation."))}get typeInfo(){let e=super.typeInfo;return e.name="Transaction Operation (RAW)",e.hierarchy.push(e.name),e}decodeFromBytes(e,t={},n=null){const o=super.decodeFromBytes(e),i=new s(o.sender,o.target,o.amount);return i.withFee(o.fee),i.withPayload(o.payload),i.withNOperation(o.nOperation),i.withSign(o.r,o.s),i}}},function(e,t,n){const o=n(1),i=n(0).Types.Keys.PublicKey,r=n(0).Types.AccountNumber,s=n(0).Types.Currency,a=Symbol("account_signer"),c=Symbol("account_target"),p=Symbol("price"),u=Symbol("account_to_pay"),d=Symbol("new_public_key"),h=Symbol("locked_until_block");e.exports=class extends o{get opType(){return 4}constructor(e,t,n,o){super(),this[a]=new r(e),this[c]=new r(t),this[p]=new s(n),this[u]=new r(o),this[d]=i.empty(),this[h]=0}get signer(){return this[a]}get target(){return this[c]}get price(){return this[p]}get accountToPay(){return this[u]}get newPublicKey(){return this[d]}get lockedUntilBlock(){return this[h]}asPrivateSale(e,t=0){this[d]=e,this[h]=parseInt(t,10)}}},function(e,t,n){const o=n(0).Types.Keys.PublicKey,i=n(0).Coding,r=n(0).Endian,s=n(2),a=i.CompositeType,c=n(16);e.exports=class extends a{constructor(){super("list_operation_raw"),this.description("The coder for the raw representation of a List Account operation"),this.addSubType(new i.Pascal.AccountNumber("signer").description("The account that executes the operation.")),this.addSubType(new i.Pascal.AccountNumber("target").description("The account that will be listed.")),this.addSubType(new i.Pascal.OpType("optype",2).withFixedValue(4).description("The optype of the operation (4)")),this.addSubType((new i.Pascal.NOperation).description("The next n_operation of the signer.")),this.addSubType(new i.Pascal.Currency("price").description("The price of the target account.")),this.addSubType(new i.Pascal.AccountNumber("accountToPay").description("The account where the amount goes to when the target is sold.")),this.addSubType(new i.Pascal.Keys.PublicKey("v2_pubkey").description("Empty pubkey (6 zero bytes) - previously active in <= v2.").withFixedValue(o.empty())),this.addSubType(new s("newPublicKey").description("The new public key of the buyer (private sale).")),this.addSubType(new i.Core.Int32("lockedUntilBlock",!0,r.LITTLE_ENDIAN).description("The block number until the account is locked.")),this.addSubType(new i.Pascal.Currency("fee").description("The fee associated with the operation")),this.addSubType(new i.Core.BytesWithLength("payload",2).description("The payload of the operation.")),this.addSubType(new i.Core.BytesWithLength("r",2).description("R value of the signed operation.")),this.addSubType(new i.Core.BytesWithLength("s",2).description("S value of the signed operation."))}get typeInfo(){let e=super.typeInfo;return e.name="List Operation (RAW)",e.hierarchy.push(e.name),e}decodeFromBytes(e,t={},n=null){const o=super.decodeFromBytes(e),i=new c(o.signer,o.target,o.price,o.accountToPay);return i.asPrivateSale(o.newPublicKey,o.lockedUntilBlock),i.withFee(o.fee),i.withPayload(o.payload),i.withNOperation(o.nOperation),i.withSign(o.r,o.s),i}}},function(e,t,n){const o=n(1),i=n(0).Types.Keys.PublicKey,r=n(0).Types.AccountNumber,s=n(0).Types.Currency,a=Symbol("account_signer"),c=Symbol("account_target"),p=Symbol("price"),u=Symbol("account_to_pay"),d=Symbol("new_public_key"),h=Symbol("locked_until_block");e.exports=class extends o{get opType(){return 5}constructor(e,t){super(),this[a]=new r(e),this[c]=new r(t),this[p]=new s(0),this[u]=new r(0),this[d]=i.empty(),this[h]=0}get signer(){return this[a]}get target(){return this[c]}get price(){return this[p]}get accountToPay(){return this[u]}get newPublicKey(){return this[d]}get lockedUntilBlock(){return this[h]}}},function(e,t,n){const o=n(0).Coding,i=o.CompositeType,r=n(18);e.exports=class extends i{constructor(){super("delist_operation_raw"),this.description("The coder for the raw representation of a Delist Account operation"),this.addSubType(new o.Pascal.AccountNumber("signer").description("The account that executes the operation.")),this.addSubType(new o.Pascal.AccountNumber("target").description("The account that will be listed.")),this.addSubType(new o.Pascal.OpType("optype",2).withFixedValue(5).description("The optype of the operation (5)")),this.addSubType((new o.Pascal.NOperation).description("The next n_operation of the signer.")),this.addSubType(new o.Pascal.Currency("fee").description("The fee associated with the operation")),this.addSubType(new o.Core.BytesWithLength("payload",2).description("The payload of the operation.")),this.addSubType(new o.Core.BytesWithLength("r",2).description("R value of the signed operation.")),this.addSubType(new o.Core.BytesWithLength("s",2).description("R value of the signed operation."))}get typeInfo(){let e=super.typeInfo;return e.name="Delist Operation (RAW)",e.hierarchy.push(e.name),e}decodeFromBytes(e,t={},n=null){const o=super.decodeFromBytes(e),i=new r(o.signer,o.target);return i.withFee(o.fee),i.withPayload(o.payload),i.withNOperation(o.nOperation),i.withSign(o.r,o.s),i}}},function(e,t,n){const o=n(1),i=n(0).Types.Currency,r=n(0).Types.AccountNumber,s=Symbol("sender"),a=Symbol("target"),c=Symbol("amount"),p=Symbol("price"),u=Symbol("seller"),d=Symbol("new_public_key");e.exports=class extends o{get opType(){return 6}constructor(e,t,n,o,h,y){super(),this[s]=new r(e),this[a]=new r(t),this[c]=new i(n),this[p]=new i(o),this[u]=new r(h),this[d]=y}get sender(){return this[s]}get target(){return this[a]}get amount(){return this[c]}get price(){return this[p]}get seller(){return this[u]}get newPublicKey(){return this[d]}}},function(e,t,n){const o=n(0).Coding,i=n(0).Endian,r=o.CompositeType,s=n(0).Types.Keys.PublicKey,a=n(20);e.exports=class extends r{constructor(){super("buy_op_raw"),this.description("The coder for the raw representation of a BuyAccount operation"),this.addSubType(new o.Pascal.AccountNumber("sender").description("The buyer account.")),this.addSubType((new o.Pascal.NOperation).description("The next n_operation value of the buyer.")),this.addSubType(new o.Pascal.AccountNumber("target").description("The account to buy.")),this.addSubType(new o.Pascal.Currency("amount").description("The amount to pay for the account.")),this.addSubType(new o.Pascal.Currency("fee").description("The fee paid for the operation.")),this.addSubType(new o.Core.BytesWithLength("payload",2).description("The payload of the operation.")),this.addSubType(new o.Pascal.Keys.PublicKey("v2_public_key").description("Empty pubkey (6 zero bytes) - previously active in <= v2.").withFixedValue(s.empty())),this.addSubType(new o.Core.Int8("type",!0,i.LITTLE_ENDIAN).description('Fixed type for a "Buy account" transaction.').withFixedValue(2)),this.addSubType(new o.Pascal.Currency("price").description("The price of the account.")),this.addSubType(new o.Pascal.AccountNumber("seller").description("The account number of the seller.")),this.addSubType(new o.Pascal.Keys.PublicKey("newPublicKey").description("The new public key that will own the account.")),this.addSubType(new o.Core.BytesWithLength("r",2).description("R value of the sign operation.")),this.addSubType(new o.Core.BytesWithLength("s",2).description("S value of the sign operation."))}get typeInfo(){let e=super.typeInfo;return e.name="Buy Account Operation (RAW)",e.hierarchy.push(e.name),e}decodeFromBytes(e,t={},n=null){const o=super.decodeFromBytes(e),i=new a(o.sender,o.target,o.amount,o.price,o.seller,o.newPublicKey);return i.withFee(o.fee),i.withPayload(o.payload),i.withNOperation(o.nOperation),i.withSign(o.r,o.s),i}}},function(e,t,n){const o=n(1),i=n(35),r=n(36),s=Symbol("operations"),a=Symbol("changers"),c=Symbol("senders"),p=Symbol("receivers"),u=Symbol("receivers_uq"),d=Symbol("keypairs");e.exports=class extends o{get opType(){return 9}constructor(){super(),this[s]=[],this[c]={},this[p]=[],this[a]={},this[u]={},this[d]={}}addTransaction(e,t,n=null){if(void 0===this[c][t.sender]){let e=new r(t.sender,t.amount);e.withNOperation(t.nOperation),e.withPayload(t.payload),this[c][t.sender]=e}else this[c][t.sender].addAmount(t.amount);this[d][t.sender]=e;let o=new i(t.target,t.amount);o.withPayload(n||t.payload);const s=o.payload.toHex()+o.amount.toStringOpt();if(void 0!==this[u][s])throw new Error("Receivers must have unique amount and payload.");this[u][s]=s,this[p].push(o)}get senders(){return Object.values(this[c])}get sendersCount(){return this.senders.length}get receivers(){return this[p]}get receiversCount(){return this[p].length}get changers(){return Object.values(this[a])}get changersCount(){return this.changers.length}}},function(e,t,n){const o=n(0).Coding,i=n(0).Endian,r=n(15),s=n(13),a=n(17),c=n(19),p=n(21),u=n(7),d=n(9),h=n(11),y=n(3),l=o.CompositeType;e.exports=class extends l{constructor(){super("combined signed operations"),super.description("Coder to combine multiple operations"),this.addSubType(new o.Core.Int32("count",!0,i.LITTLE_ENDIAN));const e=new l("operation");e.addSubType(new o.Pascal.OpType("optype",4)),e.addSubType(new o.Decissive("operation","optype",e=>{switch(e){case 1:return new r;case 2:return new u;case 4:return new a;case 5:return new c;case 6:return new p;case 7:return new d;case 8:return new h;case 9:return new y;case 10:return new s;default:throw new Error("Unable to map marker to a coder.")}})),this.addSubType(new o.Repeating("operations",e))}}},function(e,t,n){e.exports=n(25)},function(e,t,n){e.exports={Signer:n(4),RawOperations:n(37),RawOperationsCoder:n(23),Coding:{PublicKeyWithLength:n(2)},Operations:n(5)}},function(e,n){e.exports=t},function(e,t,n){const o=n(0).Coding,i=n(0).Types.Keys.PublicKey,r=o.CompositeType;e.exports=class extends r{constructor(){super("data_op_digest"),this.description("Digest encoder for a ChangeKey operation."),this.addSubType(new o.Pascal.AccountNumber("signer").description("The account that executes the operation.")),this.addSubType((new o.Pascal.NOperation).description("The next n_operation of the signer.")),this.addSubType(new o.Pascal.Currency("fee").description("The fee associated with the operation")),this.addSubType(new o.Core.BytesWithoutLength("payload").description("The payload of the operation.")),this.addSubType(new o.Pascal.Keys.Curve("v2_pubkey_curve").description("Curve ID 0 - previously active in <= v2.").withFixedValue(i.empty().curve)),this.addSubType(new o.Pascal.Keys.PublicKey("newPublicKey").description("The new public key of the account.")),this.addSubType(new o.Pascal.OpType("optype",1).withFixedValue(2).description("The optype as 8bit int."))}get typeInfo(){let e=super.typeInfo;return e.name="Change Key Operation (DIGEST)",e.hierarchy.push(e.name),e}get canDecode(){return!1}}},function(e,t,n){const o=n(0).Coding,i=n(0).Types.Keys.PublicKey,r=o.CompositeType;e.exports=class extends r{constructor(){super("change_key_signed_op_digest"),this.description("Digest encoder for a ChangeKeySigned operation."),this.addSubType(new o.Pascal.AccountNumber("signer").description("The account that executes the operation.")),this.addSubType(new o.Pascal.AccountNumber("target").description("The account that should be changed.")),this.addSubType((new o.Pascal.NOperation).description("The next n_operation of the signer.")),this.addSubType(new o.Pascal.Currency("fee").description("The fee associated with the operation")),this.addSubType(new o.Core.BytesWithoutLength("payload").description("The payload of the operation.")),this.addSubType(new o.Pascal.Keys.Curve("v2_pubkey_curve").description("Curve ID 0 - previously active in <= v2.").withFixedValue(i.empty().curve)),this.addSubType(new o.Pascal.Keys.PublicKey("newPublicKey").description("The new public key of the account.")),this.addSubType(new o.Pascal.OpType("optype",1).withFixedValue(7).description("The optype as 8bit int."))}get typeInfo(){let e=super.typeInfo;return e.name="Change Key Signed Operation (DIGEST)",e.hierarchy.push(e.name),e}get canDecode(){return!1}}},function(e,t,n){const o=n(0).Coding,i=n(0).Types.Keys.PublicKey,r=o.CompositeType;e.exports=class extends r{constructor(){super("change_info_op_digest"),this.description("Digest encoder for a ChangeAccountInfo operation."),this.addSubType(new o.Pascal.AccountNumber("signer").description("The signer of the operation.")),this.addSubType(new o.Pascal.AccountNumber("target").description("The target account to change info of.")),this.addSubType((new o.Pascal.NOperation).description("The next n_operation value of the signer.")),this.addSubType(new o.Pascal.Currency("fee").description("The fee paid for the operation.")),this.addSubType(new o.Core.BytesWithLength("payload",2).description("The payload of the operation.")),this.addSubType(new o.Pascal.Keys.PublicKey("v2_public_key").description("Empty pubkey (6 zero bytes) - previously active in <= v2.").withFixedValue(i.empty())),this.addSubType(new o.Core.Int8("changeType").description("The change type.")),this.addSubType(new o.Pascal.Keys.PublicKey("newPublicKey").description("The new public key of the account.")),this.addSubType(new o.Pascal.AccountName("newName").description("The new name of the account.")),this.addSubType(new o.Core.Int16("newType").description("The new type of the account.")),this.addSubType(new o.Pascal.OpType("optype",1).withFixedValue(8).description("The change account info optype as 8 bit int8"))}get typeInfo(){let e=super.typeInfo;return e.name="Change Account Info Operation (DIGEST)",e.hierarchy.push(e.name),e}get canDecode(){return!1}}},function(e,t,n){const o=n(0).Coding,i=n(0).Endian,r=o.CompositeType;e.exports=class extends r{constructor(){super("data_op_digest"),this.description("Digest encoder for a DATA operation."),this.addSubType(new o.Pascal.AccountNumber("signer").description("The account that executes the operation.")),this.addSubType(new o.Pascal.AccountNumber("sender").description("The account that sends the operation.")),this.addSubType(new o.Pascal.AccountNumber("target").description("The account that will receive the operation.")),this.addSubType((new o.Pascal.NOperation).description("The next n_operation of the signer.")),this.addSubType(new o.Core.Int16("dataType",!0,i.LITTLE_ENDIAN).description("The data type of the operation.")),this.addSubType(new o.Core.Int16("dataSequence",!0,i.LITTLE_ENDIAN).description("The data sequence of the operation.")),this.addSubType(new o.Pascal.Currency("amount").description("The amount associated with the operation.")),this.addSubType(new o.Pascal.Currency("fee").description("The fee associated with the operation")),this.addSubType(new o.Core.BytesWithLength("payload",2).description("The payload of the operation.")),this.addSubType(new o.Pascal.OpType("optype",1).withFixedValue(10).description("The optype as 8bit int."))}get typeInfo(){let e=super.typeInfo;return e.name="Data Operation (DIGEST)",e.hierarchy.push(e.name),e}get canDecode(){return!1}}},function(e,t,n){const o=n(0).Coding,i=n(0).Types.Keys.PublicKey,r=o.CompositeType;e.exports=class extends r{constructor(){super("tx_op_digest"),this.description("Digest encoder for a Transaction operation."),this.addSubType(new o.Pascal.AccountNumber("sender").description("The sender account.")),this.addSubType(new o.Pascal.NOperation("nOperation").description("The next n_operation value of the sender.")),this.addSubType(new o.Pascal.AccountNumber("target").description("The receiving account.")),this.addSubType(new o.Pascal.Currency("amount").description("The amount that is sent from sender to receiver.")),this.addSubType(new o.Pascal.Currency("fee").description("The fee included in the operation.")),this.addSubType(new o.Core.BytesWithoutLength("payload").description("The payload of the operation.")),this.addSubType(new o.Pascal.Keys.Curve("v2_pubkey_curve").description("Curve ID 0 - previously active in <= v2.").withFixedValue(i.empty().curve)),this.addSubType(new o.Pascal.OpType("optype",1).description("Operation type.").withFixedValue(1))}get typeInfo(){let e=super.typeInfo;return e.name="Transaction Operation (DIGEST)",e.hierarchy.push(e.name),e}get canDecode(){return!1}}},function(e,t,n){const o=n(0).Coding,i=n(0).Types.Keys.PublicKey,r=n(0).Endian,s=o.CompositeType;e.exports=class extends s{constructor(){super("list_op_digest"),this.description("Digest encoder for a List operation."),this.addSubType(new o.Pascal.AccountNumber("signer").description("The account that executes the operation.")),this.addSubType(new o.Pascal.AccountNumber("target").description("The account that will be listed.")),this.addSubType((new o.Pascal.NOperation).description("The next n_operation of the signer.")),this.addSubType(new o.Pascal.Currency("price").description("The price of the target account.")),this.addSubType(new o.Pascal.AccountNumber("accountToPay").description("The account where the amount goes to when the target is sold.")),this.addSubType(new o.Pascal.Currency("fee").description("The fee associated with the operation")),this.addSubType(new o.Core.StringWithoutLength("payload").description("The payload of the operation.")),this.addSubType(new o.Pascal.Keys.Curve("v2_pubkey_curve").withFixedValue(i.empty().curve).description("Curve ID 0 - previously active in <= v2.")),this.addSubType(new o.Pascal.Keys.PublicKey("newPublicKey").description("The new public key of the buyer (private sale).")),this.addSubType(new o.Core.Int32("lockedUntilBlock",!0,r.LITTLE_ENDIAN).description("The block number until the account is locked.")),this.addSubType(new o.Pascal.OpType("optype",1).withFixedValue(4).description("The optype as 8bit int."))}get typeInfo(){let e=super.typeInfo;return e.name="List Account Operation (DIGEST)",e.hierarchy.push(e.name),e}get canDecode(){return!1}}},function(e,t,n){const o=n(0).Coding,i=n(0).Types.Keys.PublicKey,r=o.CompositeType;e.exports=class extends r{constructor(){super("delist_op_digest"),this.description("Digest encoder for a Delist operation."),this.addSubType(new o.Pascal.AccountNumber("signer").description("The account that executes the operation.")),this.addSubType(new o.Pascal.AccountNumber("target").description("The account that will be de-listed.")),this.addSubType((new o.Pascal.NOperation).description("The next n_operation of the signer.")),this.addSubType(new o.Pascal.Currency("price").description("The price of the target account.")),this.addSubType(new o.Pascal.AccountNumber("accountToPay").description("The account where the amount goes to when the target is sold.")),this.addSubType(new o.Pascal.Currency("fee").description("The fee associated with the operation")),this.addSubType(new o.Core.BytesWithoutLength("payload").description("The payload of the operation.")),this.addSubType(new o.Pascal.Keys.Curve("v2_pubkey_curve").withFixedValue(i.empty().curve).description("Curve ID 0 - previously active in <= v2.")),this.addSubType(new o.Pascal.Keys.PublicKey("newPublicKey").description("The new public key of the buyer (private sale).")),this.addSubType(new o.Core.Int32("lockedUntilBlock").description("The block number until the account is locked.")),this.addSubType(new o.Pascal.OpType("optype",1).withFixedValue(5).description("The optype as 8bit int."))}get typeInfo(){let e=super.typeInfo;return e.name="Delist Account Operation (DIGEST)",e.hierarchy.push(e.name),e}get canDecode(){return!1}}},function(e,t,n){const o=n(0).Coding,i=n(0).Types.Keys.PublicKey,r=o.CompositeType;e.exports=class extends r{constructor(){super("buy_op_digest"),super.description("Digest encoder for a BuyAccount operation."),this.addSubType(new o.Pascal.AccountNumber("sender").description("The buyer account.")),this.addSubType((new o.Pascal.NOperation).description("The next n_operation value of the buyer.")),this.addSubType(new o.Pascal.AccountNumber("target").description("The account to buy")),this.addSubType(new o.Pascal.Currency("amount").description("The amount paid for the account.")),this.addSubType(new o.Pascal.Currency("fee").description("The fee paid for the operation.")),this.addSubType(new o.Core.BytesWithoutLength("payload").description("The payload of the operation.")),this.addSubType(new o.Pascal.Keys.Curve("v2_pubkey_curve").description("Curve ID 0 - previously active in <= v2.").withFixedValue(i.empty().curve)),this.addSubType(new o.Pascal.Currency("price").description("The price of the account to buy")),this.addSubType(new o.Pascal.AccountNumber("seller").description("The account number of the seller")),this.addSubType(new o.Pascal.Keys.PublicKey("newPublicKey",!0).description("The new public key of the account.")),this.addSubType(new o.Pascal.OpType("optype",1).withFixedValue(6).description("The buy account optype as 8 bit int8"))}get typeInfo(){let e=super.typeInfo;return e.name="Buy Account Operation (DIGEST)",e.hierarchy.push(e.name),e}get canDecode(){return!1}}},function(e,t,n){const o=n(1),i=n(0).Types.AccountNumber,r=n(0).Types.Currency,s=Symbol("account"),a=Symbol("amount");e.exports=class extends o{constructor(e,t){super(),this[s]=new i(e),this[a]=new r(t)}get account(){return this[s]}get amount(){return this[a]}}},function(e,t,n){const o=n(1),i=n(0).Types.AccountNumber,r=n(0).Types.Currency,s=Symbol("account"),a=Symbol("amount");e.exports=class extends o{constructor(e,t){super(),this[s]=new i(e),this[a]=new r(t)}get account(){return this[s]}addAmount(e){this[a]=this[a].add(new r(e))}get amount(){return this[a]}}},function(e,t,n){const o=n(4),i=n(23),r=Symbol("operations"),s=Symbol("coder"),a=Symbol("signer");e.exports=class{constructor(){this[r]=[],this[s]=new i,this[a]=new o}addOperation(e,t){if(t.isSigned)throw new Error("Operation should not be signed.");let n=this[a].sign(e,t);return t.withSign(n.r,n.s),this[r].push({optype:t.opType,operation:t}),this}get operations(){return this[r]}get count(){return this[r].length}}}])});
//# sourceMappingURL=signing.light.min.js.map