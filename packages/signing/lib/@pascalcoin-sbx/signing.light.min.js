!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t(require("@pascalcoin-sbx/common"),require("@pascalcoin-sbx/crypto")):"function"==typeof define&&define.amd?define("@pascalcoin-sbx/signing",["@pascalcoin-sbx/common","@pascalcoin-sbx/crypto"],t):"object"==typeof exports?exports["@pascalcoin-sbx/signing"]=t(require("@pascalcoin-sbx/common"),require("@pascalcoin-sbx/crypto")):e["@pascalcoin-sbx/signing"]=t(e["@pascalcoin-sbx/common"],e["@pascalcoin-sbx/crypto"])}("undefined"!=typeof self?self:this,function(e,t){return function(e){var t={};function n(o){if(t[o])return t[o].exports;var i=t[o]={i:o,l:!1,exports:{}};return e[o].call(i.exports,i,i.exports,n),i.l=!0,i.exports}return n.m=e,n.c=t,n.d=function(e,t,o){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:o})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var o=Object.create(null);if(n.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var i in e)n.d(o,i,function(t){return e[t]}.bind(null,i));return o},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=17)}([function(t,n){t.exports=e},function(e,t,n){const o=n(0).BC,i=n(0).Types.Currency,s=n(0).PascalCoinInfo,r=Symbol("payload"),a=Symbol("s"),c=Symbol("r"),p=Symbol("fee"),u=Symbol("nOperation");e.exports=class{constructor(){this[r]=o.fromString(""),this[a]=null,this[c]=null,this[p]=new i(0)}withPayload(e){return this[r]=e,this}withFee(e){return this[p]=new i(e),this}withMinFee(e=null){return this[p]=s.MIN_FEE(e),this}withNOperation(e){return this[u]=e,this}withSign(e,t){this[c]=e,this[a]=t}get payload(){return this[r]}get r(){return this[c]}get s(){return this[a]}get fee(){return this[p]}get nOperation(){return this[u]}get isSigned(){return null!==this[a]&&null!==this[c]}usesDigestToSign(){return!1}}},function(e,t,n){const o=n(0).Sha,i=n(19).Keys,s=n(3);e.exports=class{sign(e,t){const n=new(s.digestCoderFor(t))(t.opType).encodeToBytes(t);let r;return r=!0===t.usesDigestToSign()?function(e,t){return i.sign(e,t)}(e,n):function(e,t){const n=o.sha256(t);return i.sign(e,n)}(e,n)}}},function(e,t,n){let o={ChangeKey:n(20),ChangeKeySigned:n(21),ChangeAccountInfo:{Operation:n(4),RawCoder:n(5),DigestCoder:n(22)},Data:{Operation:n(6),RawCoder:n(7),DigestCoder:n(23)},Transaction:{Operation:n(8),RawCoder:n(9),DigestCoder:n(24)},ListAccountForSale:{Operation:n(10),RawCoder:n(11),DigestCoder:n(25)},DeListAccountForSale:{Operation:n(13),RawCoder:n(14),DigestCoder:n(26)},BuyAccount:{Operation:n(15),RawCoder:n(27),DigestCoder:n(28)},digestCoderFor:e=>o[e.constructor.name].DigestCoder,rawCoderFor:e=>o[e.constructor.name].RawCoder};e.exports=o},function(e,t,n){const o=n(1),i=n(0).BC,s=n(0).Types.Keys.PublicKey,r=n(0).Types.AccountNumber,a=n(0).Types.AccountName,c=Symbol("account_signer"),p=Symbol("account_target"),u=Symbol("new_public_key"),d=Symbol("new_name"),h=Symbol("new_type"),y=Symbol("with_new_pubkey"),l=Symbol("with_new_name"),b=Symbol("with_new_type");e.exports=class extends o{get opType(){return 8}constructor(e,t){super(),this[c]=new r(e),this[p]=new r(t),this[u]=s.empty(),this[d]=i.fromString(""),this[h]=0,this[y]=!1,this[l]=!1,this[b]=!1}get signer(){return this[c]}get target(){return this[p]}get newPublicKey(){return this[u]}get newName(){return this[d]}get newType(){return this[h]}get changeType(){let e=0;return!0===this[y]&&(e|=1),!0===this[l]&&(e|=2),!0===this[b]&&(e|=4),e}withNewPublicKey(e){return this[u]=e,this[y]=!0,this}withNewName(e){return this[d]=new a(e),this[l]=!0,this}withNewType(e){return this[h]=e,this[b]=!0,this}}},function(e,t,n){const o=n(0).Coding,i=o.CompositeType,s=n(0).Types.Keys.PublicKey,r=n(4);e.exports=class extends i{constructor(e){super("buy_operation_raw"),this.description("Encoded BuyAccount Operation"),this.addSubType(new o.Pascal.AccountNumber("signer").description("The signer of the operation.")),this.addSubType(new o.Pascal.AccountNumber("target").description("The target account to change info of.")),this.addSubType((new o.Pascal.NOperation).description("The next n_operation value of the buyer.")),this.addSubType(new o.Pascal.Currency("fee").description("The fee paid for the operation.")),this.addSubType(new o.Core.BytesWithLength("payload",2).description("The payload of the operation.")),this.addSubType(new o.Pascal.Keys.PublicKey("v2_public_key").description("Empty pubkey (6 zero bytes) - previously active in <= v2.").withFixedValue(s.empty())),this.addSubType(new o.Core.Int8("changeType").description("The change type.")),this.addSubType(new o.Pascal.Keys.PublicKey("newPublicKey").description("The new public key of the account.")),this.addSubType(new o.Pascal.AccountName("newName").description("The new name of the account.")),this.addSubType(new o.Core.Int16("newType").description("The new type of the account.")),this.addSubType(new o.Core.BytesWithLength("r",2).description("R value of the sign operation.")),this.addSubType(new o.Core.BytesWithLength("s",2).description("S value of the sign operation."))}decodeFromBytes(e){const t=super.decodeFromBytes(e),n=new r(t.signer,t.target);return n.withNewType(t.type),n.withNewName(t.name),n.withNewPublicKey(t.newPublicKey),n.withFee(t.fee),n.withPayload(t.payload),n.signFromDecoded(t.nOperation,t.r,t.s),n}}},function(e,t,n){const o=n(1),i=n(0).Types.AccountNumber,s=n(0).Types.Currency,r=Symbol("account_signer"),a=Symbol("account_sender"),c=Symbol("account_target"),p=Symbol("data_type"),u=Symbol("data_sequence"),d=Symbol("amount");e.exports=class extends o{get opType(){return 10}constructor(e,t,n){super(),this[r]=new i(e),this[a]=new i(t),this[c]=new i(n),this[p]=0,this[u]=0,this[d]=new s(0)}withDataType(e){return this[p]=parseInt(e,10),this}withDataSequence(e){return this[u]=parseInt(e,10),this}withAmount(e){return this[d]=new s(e),this}get signer(){return this[r]}get sender(){return this[a]}get target(){return this[c]}get dataType(){return this[p]}get dataSequence(){return this[u]}get amount(){return this[d]}usesDigestToSign(){return!0}}},function(e,t,n){const o=n(0).Coding,i=n(0).Endian,s=o.CompositeType,r=n(6);e.exports=class extends s{constructor(e){super("data_operation_raw"),this.addSubType(new o.Pascal.AccountNumber("signer").description("The account that executes the operation.")),this.addSubType(new o.Pascal.AccountNumber("sender").description("The account that sends the operation.")),this.addSubType(new o.Pascal.AccountNumber("target").description("The account that will receive the operation.")),this.addSubType((new o.Pascal.NOperation).description("The next n_operation of the signer.")),this.addSubType(new o.Core.Int16("dataType",!0,i.LITTLE_ENDIAN).description("The data type of the operation.")),this.addSubType(new o.Core.Int16("dataSequence",!0,i.LITTLE_ENDIAN).description("The data sequence of the operation.")),this.addSubType(new o.Pascal.Currency("amount").description("The amount associated the operation.")),this.addSubType(new o.Pascal.Currency("fee").description("The fee associated the operation.")),this.addSubType(new o.Core.BytesWithLength("payload",2).description("The payload of the operation.")),this.addSubType(new o.Core.BytesWithLength("r",2).description("R value of the signed operation.")),this.addSubType(new o.Core.BytesWithLength("s",2).description("R value of the signed operation."))}decodeFromBytes(e){const t=super.decodeFromBytes(e),n=new r(t.signer,t.sender,t.target);return n.withDataType(t.dataType),n.withDataSequence(t.dataSequence),n.withAmount(t.amount),n.withFee(t.fee),n.withPayload(t.payload),n.signFromDecoded(t.nOperation,t.r,t.s),n}}},function(e,t,n){const o=n(1),i=n(0).Types.Currency,s=n(0).Types.AccountNumber,r=Symbol("sender"),a=Symbol("target"),c=Symbol("amount");e.exports=class extends o{get opType(){return 1}get sender(){return this[r]}get target(){return this[a]}get amount(){return this[c]}constructor(e,t,n){super(),this[r]=new s(e),this[a]=new s(t),this[c]=new i(n)}}},function(e,t,n){const o=n(0).Coding,i=n(0).Types.Keys.PublicKey,s=o.CompositeType,r=n(8);e.exports=class extends s{constructor(){super("data_operation_raw"),this.addSubType(new o.Pascal.AccountNumber("sender").description("The sender account.")),this.addSubType(new o.Pascal.NOperation("nOperation").description("The next n_operation value of the sender.")),this.addSubType(new o.Pascal.AccountNumber("target").description("The receiving account.")),this.addSubType(new o.Pascal.Currency("amount").description("The amount that is sent from sender to receiver.")),this.addSubType(new o.Pascal.Currency("fee").description("The fee included in the operation.")),this.addSubType(new o.Core.BytesWithLength("payload",2).description("The payload of the operation.")),this.addSubType(new o.Pascal.Keys.PublicKey("v2_pubkey").description("Empty pubkey (6 zero bytes) - previously active in <= v2.").withFixedValue(i.empty())),this.addSubType(new o.Core.BytesWithLength("r",2).description("R value of the signed operation.")),this.addSubType(new o.Core.BytesWithLength("s",2).description("S value of the signed operation."))}decodeFromBytes(e){const t=super.decodeFromBytes(e),n=new r(t.sender,t.target,t.amount);return n.withFee(t.fee),n.withPayload(t.payload),n.signFromDecoded(t.nOperation,t.r,t.s),n}}},function(e,t,n){const o=n(1),i=n(0).Types.Keys.PublicKey,s=n(0).Types.AccountNumber,r=n(0).Types.Currency,a=Symbol("account_signer"),c=Symbol("account_target"),p=Symbol("price"),u=Symbol("account_to_pay"),d=Symbol("new_public_key"),h=Symbol("locked_until_block");e.exports=class extends o{get opType(){return 4}constructor(e,t,n,o){super(),this[a]=new s(e),this[c]=new s(t),this[p]=new r(n),this[u]=new s(o),this[d]=i.empty(),this[h]=0}get signer(){return this[a]}get target(){return this[c]}get price(){return this[p]}get accountToPay(){return this[u]}get newPublicKey(){return this[d]}get lockedUntilBlock(){return this[h]}asPrivateSale(e,t=0){this[d]=e,this[h]=parseInt(t,10)}}},function(e,t,n){const o=n(0).Types.Keys.PublicKey,i=n(0).Coding,s=n(0).Endian,r=n(12),a=i.CompositeType,c=n(10);e.exports=class extends a{constructor(e){super("list_operation_raw"),this.addSubType(new i.Pascal.AccountNumber("signer").description("The account that executes the operation.")),this.addSubType(new i.Pascal.AccountNumber("target").description("The account that will be listed.")),this.addSubType(new i.Pascal.OpType("optype",2).withFixedValue(e).description(`The optype of the operation (${e})`)),this.addSubType((new i.Pascal.NOperation).description("The next n_operation of the signer.")),this.addSubType(new i.Pascal.Currency("price").description("The price of the target account.")),this.addSubType(new i.Pascal.AccountNumber("accountToPay").description("The account where the amount goes to when the target is sold.")),this.addSubType(new i.Pascal.Keys.PublicKey("v2_pubkey").description("Empty pubkey (6 zero bytes) - previously active in <= v2.").withFixedValue(o.empty())),this.addSubType(new r("newPublicKey").description("The new public key of the buyer (private sale).")),this.addSubType(new i.Core.Int32("lockedUntilBlock",!0,s.LITTLE_ENDIAN).description("The block number until the account is locked.")),this.addSubType(new i.Pascal.Currency("fee").description("The fee associated with the operation")),this.addSubType(new i.Core.BytesWithLength("payload",2).description("The payload of the operation.")),this.addSubType(new i.Core.BytesWithLength("r",2).description("R value of the signed operation.")),this.addSubType(new i.Core.BytesWithLength("s",2).description("S value of the signed operation."))}decodeFromBytes(e){const t=super.decodeFromBytes(e),n=new c(t.signer,t.target,t.price,t.accountToPay);return n.asPrivateSale(t.newPublicKey,t.lockedUntilBlock),n.withFee(t.fee),n.withPayload(t.payload),n.signFromDecoded(t.nOperation,t.r,t.s),n}}},function(e,t,n){const o=n(0).Coding.Pascal.Keys.PublicKey,i=n(0).Coding.Core.BytesWithLength,s=n(0).Types.Keys.PublicKey,r=new o;e.exports=class extends i{constructor(e=null){super(e||"pubkey",16)}decodeFromBytes(e){const t=super.decodeFromBytes(e),n=r.decodeFromBytes(t);return new s(n.x,n.y,n.curve)}encodeToBytes(e){return super.encodeToBytes(r.encodeToBytes(e))}}},function(e,t,n){const o=n(1),i=n(0).Types.Keys.PublicKey,s=n(0).Types.AccountNumber,r=n(0).Types.Currency,a=Symbol("account_signer"),c=Symbol("account_target"),p=Symbol("price"),u=Symbol("account_to_pay"),d=Symbol("new_public_key"),h=Symbol("locked_until_block");e.exports=class extends o{get opType(){return 5}constructor(e,t){super(),this[a]=new s(e),this[c]=new s(t),this[p]=new r(0),this[u]=new s(0),this[d]=i.empty(),this[h]=0}get signer(){return this[a]}get target(){return this[c]}get price(){return this[p]}get accountToPay(){return this[u]}get newPublicKey(){return this[d]}get lockedUntilBlock(){return this[h]}}},function(e,t,n){const o=n(0).Coding,i=o.CompositeType,s=n(13);e.exports=class extends i{constructor(e){super("delist_operation_raw"),this.addSubType(new o.Pascal.AccountNumber("signer").description("The account that executes the operation.")),this.addSubType(new o.Pascal.AccountNumber("target").description("The account that will be listed.")),this.addSubType(new o.Pascal.OpType("optype",2).withFixedValue(e).description(`The optype of the operation (${e})`)),this.addSubType((new o.Pascal.NOperation).description("The next n_operation of the signer.")),this.addSubType(new o.Pascal.Currency("fee").description("The fee associated with the operation")),this.addSubType(new o.Core.BytesWithLength("payload",2).description("The payload of the operation.")),this.addSubType(new o.Core.BytesWithLength("r",2).description("R value of the signed operation.")),this.addSubType(new o.Core.BytesWithLength("s",2).description("R value of the signed operation."))}decodeFromBytes(e){const t=super.decodeFromBytes(e),n=new s(t.signer,t.target);return n.withFee(t.fee),n.withPayload(t.payload),n.signFromDecoded(t.nOperation,t.r,t.s),n}}},function(e,t,n){const o=n(1),i=n(0).Types.Currency,s=n(0).Types.AccountNumber,r=Symbol("sender"),a=Symbol("target"),c=Symbol("amount"),p=Symbol("price"),u=Symbol("seller"),d=Symbol("new_public_key");e.exports=class extends o{get opType(){return 6}constructor(e,t,n,o,h,y){super(),this[r]=new s(e),this[a]=new s(t),this[c]=new i(n),this[p]=new i(o),this[u]=new s(h),this[d]=y}get sender(){return this[r]}get target(){return this[a]}get amount(){return this[c]}get price(){return this[p]}get seller(){return this[u]}get newPublicKey(){return this[d]}}},function(e,t,n){const o=n(0).Coding,i=n(0).Endian,s=n(9),r=n(7),a=n(11),c=n(14),p=n(5),u=o.CompositeType;e.exports=class extends u{constructor(){super("combined signed operations"),super.description("Coder to combine multiple operations"),this.addSubType(new o.Core.Int32("count",!0,i.LITTLE_ENDIAN));const e=new u("operation");e.addSubType(new o.Pascal.OpType("optype",4)),e.addSubType(new o.Decissive("operation","optype",e=>{switch(e){case 1:return new s(1);case 4:return new a(4);case 5:return new c(5);case 8:return new p(8);case 10:return new r(10);default:throw new Error("Unable to map marker to a coder.")}})),this.addSubType(new o.Repeating("operations",e))}}},function(e,t,n){e.exports=n(18)},function(e,t,n){e.exports={Signer:n(2),RawOperations:n(29),RawOperationsCoder:n(16),Coding:{PublicKeyWithLength:n(12)},Operations:n(3)}},function(e,n){e.exports=t},function(e,t,n){const o=n(1),i=n(0).BC,s=n(0).Types.Keys.PublicKey,r=n(0).Types.AccountNumber,a=Symbol("account_signer"),c=Symbol("new_public_key");class p extends o{static get OPTYPE(){return 2}constructor(e,t){super(),this[a]=new r(e),this[c]=t}digest(){return i.concat(this.bcFromInt(this[a].account,4),this.bcFromInt(this.nOperation,4),this.bcFromInt(this.fee.toMolina(),8),this.payload,this.bcFromInt(s.empty().curve.id,2),this[c].encode(),this.bcFromInt(p.OPTYPE))}toRaw(){return i.concat(this.bcFromInt(p.OPTYPE,4),this.bcFromInt(this[a].account,4),this.bcFromInt(this.nOperation,4),this.bcFromInt(this.fee.toMolina(),8),this.bcFromBcWithSize(this.payload),s.empty().encode(),this.bcFromInt(this[c].encode().length,2),this[c].encode(),this.bcFromSign(this.r,this.s))}}e.exports=p},function(e,t,n){const o=n(1),i=n(0).BC,s=n(0).Types.Keys.PublicKey,r=n(0).Types.AccountNumber,a=Symbol("account_signer"),c=Symbol("account_target"),p=Symbol("new_public_key");class u extends o{static get OPTYPE(){return 7}constructor(e,t,n){super(),this[a]=new r(e),this[c]=new r(t),this[p]=n}digest(){return i.concat(this.bcFromInt(this[a].account,4),this.bcFromInt(this[c].account,4),this.bcFromInt(this.nOperation,4),this.bcFromInt(this.fee.toMolina(),8),this.payload,this.bcFromInt(s.empty().curve.id,2),this[p].encode(),this.bcFromInt(u.OPTYPE))}toRaw(){return i.concat(this.bcFromInt(u.OPTYPE,4),this.bcFromInt(this[a].account,4),this.bcFromInt(this[c].account,4),this.bcFromInt(this.nOperation,4),this.bcFromInt(this.fee.toMolina(),8),this.bcFromBcWithSize(this.payload),s.empty().encode(),this.bcFromInt(this[p].encode().length,2),this[p].encode(),this.bcFromSign(this.r,this.s))}}e.exports=u},function(e,t,n){const o=n(0).Coding,i=n(0).Types.Keys.PublicKey,s=o.CompositeType;e.exports=class extends s{constructor(e){super("change_info_operation_digest"),this.addSubType(new o.Pascal.AccountNumber("signer").description("The signer of the operation.")),this.addSubType(new o.Pascal.AccountNumber("target").description("The target account to change info of.")),this.addSubType((new o.Pascal.NOperation).description("The next n_operation value of the buyer.")),this.addSubType(new o.Pascal.Currency("fee").description("The fee paid for the operation.")),this.addSubType(new o.Core.BytesWithLength("payload",2).description("The payload of the operation.")),this.addSubType(new o.Pascal.Keys.PublicKey("v2_public_key").description("Empty pubkey (6 zero bytes) - previously active in <= v2.").withFixedValue(i.empty())),this.addSubType(new o.Core.Int8("changeType").description("The change type.")),this.addSubType(new o.Pascal.Keys.PublicKey("newPublicKey").description("The new public key of the account.")),this.addSubType(new o.Pascal.AccountName("newName").description("The new name of the account.")),this.addSubType(new o.Core.Int16("newType").description("The new type of the account.")),this.addSubType(new o.Pascal.OpType("optype",1).withFixedValue(e).description("The buy account optype as 8 bit int8"))}}},function(e,t,n){const o=n(0).Coding,i=n(0).Endian,s=o.CompositeType;e.exports=class extends s{constructor(e){super("data_operation_digest"),this.addSubType(new o.Pascal.AccountNumber("signer").description("The account that executes the operation.")),this.addSubType(new o.Pascal.AccountNumber("sender").description("The account that sends the operation.")),this.addSubType(new o.Pascal.AccountNumber("target").description("The account that will receive the operation.")),this.addSubType((new o.Pascal.NOperation).description("The next n_operation of the signer.")),this.addSubType(new o.Core.Int16("dataType",!0,i.LITTLE_ENDIAN).description("The data type of the operation.")),this.addSubType(new o.Core.Int16("dataSequence",!0,i.LITTLE_ENDIAN).description("The data sequence of the operation.")),this.addSubType(new o.Pascal.Currency("amount").description("The amount associated with the operation.")),this.addSubType(new o.Pascal.Currency("fee").description("The fee associated with the operation")),this.addSubType(new o.Core.BytesWithLength("payload",2).description("The payload of the operation.")),this.addSubType(new o.Pascal.OpType("optype",1).withFixedValue(e).description("The optype as 8bit int."))}}},function(e,t,n){const o=n(0).Coding,i=n(0).Types.Keys.PublicKey,s=o.CompositeType;e.exports=class extends s{constructor(e){super("tx_operation_digest"),this.addSubType(new o.Pascal.AccountNumber("sender").description("The sender account.")),this.addSubType(new o.Pascal.NOperation("nOperation").description("The next n_operation value of the sender.")),this.addSubType(new o.Pascal.AccountNumber("target").description("The receiving account.")),this.addSubType(new o.Pascal.Currency("amount").description("The amount that is sent from sender to receiver.")),this.addSubType(new o.Pascal.Currency("fee").description("The fee included in the operation.")),this.addSubType(new o.Core.BytesWithoutLength("payload").description("The payload of the operation.")),this.addSubType(new o.Pascal.Keys.Curve("v2_pubkey_curve").description("Curve ID 0 - previously active in <= v2.").withFixedValue(i.empty().curve)),this.addSubType(new o.Pascal.OpType("optype",1).description("Operation type.").withFixedValue(e))}}},function(e,t,n){const o=n(0).Coding,i=n(0).Types.Keys.PublicKey,s=n(0).Endian,r=o.CompositeType;e.exports=class extends r{constructor(e){super("data_operation_digest"),this.addSubType(new o.Pascal.AccountNumber("signer").description("The account that executes the operation.")),this.addSubType(new o.Pascal.AccountNumber("target").description("The account that will be listed.")),this.addSubType((new o.Pascal.NOperation).description("The next n_operation of the signer.")),this.addSubType(new o.Pascal.Currency("price").description("The price of the target account.")),this.addSubType(new o.Pascal.AccountNumber("accountToPay").description("The account where the amount goes to when the target is sold.")),this.addSubType(new o.Pascal.Currency("fee").description("The fee associated with the operation")),this.addSubType(new o.Core.StringWithoutLength("payload").description("The payload of the operation.")),this.addSubType(new o.Pascal.Keys.Curve("v2_pubkey_curve").withFixedValue(i.empty().curve).description("Curve ID 0 - previously active in <= v2.")),this.addSubType(new o.Pascal.Keys.PublicKey("newPublicKey").description("The new public key of the buyer (private sale).")),this.addSubType(new o.Core.Int32("lockedUntilBlock",!0,s.LITTLE_ENDIAN).description("The block number until the account is locked.")),this.addSubType(new o.Pascal.OpType("optype",1).withFixedValue(e).description("The optype as 8bit int."))}}},function(e,t,n){const o=n(0).Coding,i=n(0).Types.Keys.PublicKey,s=o.CompositeType;e.exports=class extends s{constructor(e){super("delist_operation_digest"),this.addSubType(new o.Pascal.AccountNumber("signer").description("The account that executes the operation.")),this.addSubType(new o.Pascal.AccountNumber("target").description("The account that will be de-listed.")),this.addSubType((new o.Pascal.NOperation).description("The next n_operation of the signer.")),this.addSubType(new o.Pascal.Currency("price").description("The price of the target account.")),this.addSubType(new o.Pascal.AccountNumber("accountToPay").description("The account where the amount goes to when the target is sold.")),this.addSubType(new o.Pascal.Currency("fee").description("The fee associated with the operation")),this.addSubType(new o.Core.BytesWithoutLength("payload").description("The payload of the operation.")),this.addSubType(new o.Pascal.Keys.Curve("v2_pubkey_curve").withFixedValue(i.empty().curve).description("Curve ID 0 - previously active in <= v2.")),this.addSubType(new o.Pascal.Keys.PublicKey("newPublicKey").description("The new public key of the buyer (private sale).")),this.addSubType(new o.Core.Int32("lockedUntilBlock").description("The block number until the account is locked.")),this.addSubType(new o.Pascal.OpType("optype",1).withFixedValue(e).description("The optype as 8bit int."))}}},function(e,t,n){const o=n(0).Coding,i=n(0).Endian,s=o.CompositeType,r=n(0).Types.Keys.PublicKey,a=n(15);e.exports=class extends s{get typeInfo(){let e=super.typeInfo;return e.name="Buy Account Operation (RAW)",e.hierarchy.push(e.name),e}constructor(e){super("buy_operation_raw"),this.description("The coder for the raw representation of a BuyAccount operation"),this.description("Encoded BuyAccount Operation"),this.addSubType(new o.Pascal.AccountNumber("sender").description("The buyer account.")),this.addSubType((new o.Pascal.NOperation).description("The next n_operation value of the buyer.")),this.addSubType(new o.Pascal.AccountNumber("target").description("The account to buy.")),this.addSubType(new o.Pascal.Currency("amount").description("The amount to pay for the account.")),this.addSubType(new o.Pascal.Currency("fee").description("The fee paid for the operation.")),this.addSubType(new o.Core.BytesWithLength("payload",2).description("The payload of the operation.")),this.addSubType(new o.Pascal.Keys.PublicKey("v2_public_key").description("Empty pubkey (6 zero bytes) - previously active in <= v2.").withFixedValue(r.empty())),this.addSubType(new o.Core.Int8("type",!0,i.LITTLE_ENDIAN).description('Fixed type for a "Buy account" transaction.').withFixedValue(2)),this.addSubType(new o.Pascal.Currency("price").description("The price of the account.")),this.addSubType(new o.Pascal.AccountNumber("seller").description("The account number of the seller.")),this.addSubType(new o.Pascal.Keys.PublicKey("newPublicKey").description("The new public key that will own the account.")),this.addSubType(new o.Core.BytesWithLength("r",2).description("R value of the sign operation.")),this.addSubType(new o.Core.BytesWithLength("s",2).description("S value of the sign operation."))}decodeFromBytes(e){const t=super.decodeFromBytes(e),n=new a(t.sender,t.target,t.amount,t.price,t.seller,t.newPublicKey);return n.withFee(t.fee),n.withPayload(t.payload),n.signFromDecoded(t.nOperation,t.r,t.s),n}}},function(e,t,n){const o=n(0).Coding,i=n(0).Types.Keys.PublicKey,s=o.CompositeType;e.exports=class extends s{constructor(e){super("buy_operation_digest"),super.description("Digest for buy account operation"),this.addSubType(new o.Pascal.AccountNumber("sender").description("The buyer account.")),this.addSubType((new o.Pascal.NOperation).description("The next n_operation value of the buyer.")),this.addSubType(new o.Pascal.AccountNumber("target").description("The account to buy")),this.addSubType(new o.Pascal.Currency("amount").description("The amount paid for the account.")),this.addSubType(new o.Pascal.Currency("fee").description("The fee paid for the operation.")),this.addSubType(new o.Core.BytesWithoutLength("payload").description("The payload of the operation.")),this.addSubType(new o.Pascal.Keys.Curve("v2_pubkey_curve").description("Curve ID 0 - previously active in <= v2.").withFixedValue(i.empty().curve)),this.addSubType(new o.Pascal.Currency("price").description("The price of the account to buy")),this.addSubType(new o.Pascal.AccountNumber("seller").description("The account number of the seller")),this.addSubType(new o.Pascal.Keys.PublicKey("newPublicKey").description("The new public key of the account.")),this.addSubType(new o.Pascal.OpType("optype",1).withFixedValue(e).description("The buy account optype as 8 bit int8"))}}},function(e,t,n){const o=n(2),i=n(16),s=Symbol("operations"),r=Symbol("coder"),a=Symbol("signer");e.exports=class{constructor(){this[s]=[],this[r]=new i,this[a]=new o}addOperation(e,t){if(t.isSigned)throw new Error("Operation should not be signed.");let n=this[a].sign(e,t);return t.withSign(n.r,n.s),this[s].push({optype:t.opType,operation:t}),this}get operations(){return this[s]}get count(){return this[s].length}}}])});
//# sourceMappingURL=signing.light.min.js.map